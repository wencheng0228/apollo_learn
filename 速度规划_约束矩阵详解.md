# Apollo 速度规划约束矩阵详解

## 目录
1. [问题背景](#问题背景)
2. [约束矩阵总体结构](#约束矩阵总体结构)
3. [第一部分：变量边界约束](#第一部分变量边界约束)
4. [第二部分：Jerk约束](#第二部分jerk约束)
5. [第三部分：速度连续性约束](#第三部分速度连续性约束)
6. [第四部分：位置连续性约束](#第四部分位置连续性约束)
7. [第五部分：初始状态约束](#第五部分初始状态约束)
8. [完整示例](#完整示例)

---

## 问题背景

### 决策变量

在速度规划中，我们需要优化 `3n` 个变量（n 是时间节点数）：

```
x = [s₀, s₁, ..., sₙ₋₁,    ← 位置（n个）
     v₀, v₁, ..., vₙ₋₁,    ← 速度（n个）
     a₀, a₁, ..., aₙ₋₁]ᵀ   ← 加速度（n个）
```

**时间离散化：**
- 总时长：T = 8秒（默认）
- 时间步长：Δt = 0.1秒
- 节点数：n = T/Δt + 1 = 81个

### 约束的标准形式

所有约束都写成：
```
l ≤ A·x ≤ u
```

其中：
- `A`：约束矩阵，大小为 `(6n) × (3n)`
- `l`：下界向量，大小为 `(6n) × 1`
- `u`：上界向量，大小为 `(6n) × 1`

### 缩放因子简介

为了提高数值稳定性，Apollo 对优化变量进行了缩放：

```cpp
scale_factor_ = [s₀, s₁, s₂] = [1.0, 10.0, 100.0]
```

优化变量与真实物理量的关系：
```
x_opt = x_real × scale_factor
```

这使得不同量级的变量（位置~100m，速度~15m/s，加速度~2m/s²）在数值上更接近，避免病态矩阵。

**注意**：约束矩阵的系数会相应调整以保持物理方程的正确性（详见各约束部分的解释）。

---

## 约束矩阵总体结构

约束矩阵 A 包含 **6n 行约束**，分为 5 个部分：

| 约束类型 | 行数 | 代码行 | 作用 |
|---------|------|--------|------|
| 1. 变量边界 | 3n | 160-176 | 限制 s, v, a 的范围 |
| 2. Jerk 约束 | n-1 | 179-186 | 限制加速度变化率 |
| 3. 速度连续性 | n-1 | 188-197 | 确保速度曲线连续 |
| 4. 位置连续性 | n-1 | 199-213 | 确保位置曲线连续 |
| 5. 初始状态 | 3 | 215-229 | 固定起点状态 |
| **总计** | **6n** | | |

---

## 第一部分：变量边界约束

### 代码（第160-176行）

```cpp
for (int i = 0; i < num_of_variables; ++i) {
    if (i < n) {
        variables[i].emplace_back(constraint_index, 1.0);
        lower_bounds->at(constraint_index) = x_bounds_[i].first * scale_factor_[0];
        upper_bounds->at(constraint_index) = x_bounds_[i].second * scale_factor_[0];
    } else if (i < 2 * n) {
        variables[i].emplace_back(constraint_index, 1.0);
        lower_bounds->at(constraint_index) = dx_bounds_[i - n].first * scale_factor_[1];
        upper_bounds->at(constraint_index) = dx_bounds_[i - n].second * scale_factor_[1];
    } else {
        variables[i].emplace_back(constraint_index, 1.0);
        lower_bounds->at(constraint_index) = ddx_bounds_[i - 2 * n].first * scale_factor_[2];
        upper_bounds->at(constraint_index) = ddx_bounds_[i - 2 * n].second * scale_factor_[2];
    }
    ++constraint_index;
}
```

### 数学形式

这部分约束是 **3n 个单变量约束**，矩阵是单位矩阵 I：

```
约束矩阵（3n 行）:
┌                    ┐
│ 1  0  0  ...  0   │  ← s₀ 的约束
│ 0  1  0  ...  0   │  ← s₁ 的约束
│ ...               │
│ 0  0  ...  1  0   │  ← sₙ₋₁ 的约束
│ 1  0  0  ...  0   │  ← v₀ 的约束
│ 0  1  0  ...  0   │  ← v₁ 的约束
│ ...               │
│ 0  0  ...  1  0   │  ← vₙ₋₁ 的约束
│ 1  0  0  ...  0   │  ← a₀ 的约束
│ 0  1  0  ...  0   │  ← a₁ 的约束
│ ...               │
│ 0  0  ...  0  1   │  ← aₙ₋₁ 的约束
└                    ┘
```

### 上下界向量

**下界向量 l（前 3n 行）：**
```
l = [s_min,0·s₀, s_min,1·s₀, ..., s_min,n-1·s₀,          ← 位置下界（n个）
     v_min,0·s₁, v_min,1·s₁, ..., v_min,n-1·s₁,          ← 速度下界（n个）
     a_min,0·s₂, a_min,1·s₂, ..., a_min,n-1·s₂]ᵀ         ← 加速度下界（n个）
```

**上界向量 u（前 3n 行）：**
```
u = [s_max,0·s₀, s_max,1·s₀, ..., s_max,n-1·s₀,          ← 位置上界（n个）
     v_max,0·s₁, v_max,1·s₁, ..., v_max,n-1·s₁,          ← 速度上界（n个）
     a_max,0·s₂, a_max,1·s₂, ..., a_max,n-1·s₂]ᵀ         ← 加速度上界（n个）
```

其中 `scale_factor_ = [s₀, s₁, s₂] = [1.0, 10.0, 100.0]`。

**约束含义：**
```
位置边界：s_min,i · s₀ ≤ s_opt,i ≤ s_max,i · s₀
速度边界：v_min,i · s₁ ≤ v_opt,i ≤ v_max,i · s₁
加速度边界：a_min,i · s₂ ≤ a_opt,i ≤ a_max,i · s₂
```

### 示例

假设 n=3，则前 9 行约束：

```
约束    |  A矩阵的这一行        | 下界           | 上界
--------|---------------------|----------------|----------------
第0行   | [1 0 0|0 0 0|0 0 0] | 0.0            | 100.0         (s₀的范围)
第1行   | [0 1 0|0 0 0|0 0 0] | 0.0            | 100.0         (s₁的范围)
第2行   | [0 0 1|0 0 0|0 0 0] | 0.0            | 100.0         (s₂的范围)
第3行   | [0 0 0|1 0 0|0 0 0] | 0.0            | 15.0×10       (v₀的范围)
第4行   | [0 0 0|0 1 0|0 0 0] | 0.0            | 15.0×10       (v₁的范围)
第5行   | [0 0 0|0 0 1|0 0 0] | 0.0            | 15.0×10       (v₂的范围)
第6行   | [0 0 0|0 0 0|1 0 0] | -4.0×100       | 2.0×100       (a₀的范围)
第7行   | [0 0 0|0 0 0|0 1 0] | -4.0×100       | 2.0×100       (a₁的范围)
第8行   | [0 0 0|0 0 0|0 0 1] | -4.0×100       | 2.0×100       (a₂的范围)
```

---

## 第二部分：Jerk约束

### 代码（第179-186行）

```cpp
// x(i->i+1)''' = (x(i+1)'' - x(i)'') / delta_s
for (int i = 0; i + 1 < n; ++i) {
    variables[2 * n + i].emplace_back(constraint_index, -1.0);
    variables[2 * n + i + 1].emplace_back(constraint_index, 1.0);
    lower_bounds->at(constraint_index) = dddx_bound_.first * delta_s_ * scale_factor_[2];
    upper_bounds->at(constraint_index) = dddx_bound_.second * delta_s_ * scale_factor_[2];
    ++constraint_index;
}
```

### 物理意义

Jerk（急动度）是加速度的变化率：
```
j = da/dt
```

离散化后：
```
jᵢ = (aᵢ₊₁ - aᵢ) / Δt
```

### 数学形式

约束为：**j_min ≤ (aᵢ₊₁ - aᵢ)/Δt ≤ j_max**

乘以 Δt 后：
```
j_min · Δt ≤ aᵢ₊₁ - aᵢ ≤ j_max · Δt
```

再乘以缩放因子 s₂：
```
j_min · Δt · s₂ ≤ aᵢ₊₁ - aᵢ ≤ j_max · Δt · s₂
```

### 矩阵形式（n-1 行）

每一行约束对应一个时间段 [tᵢ, tᵢ₊₁]：

```
第 i 个约束（只涉及 a_opt,i 和 a_opt,i+1）：
[0 ... 0 | 0 ... 0 | 0 ... -1  1  0 ... 0] · x
                            ↑   ↑
                      a_opt,i  a_opt,i+1
```

### 上下界向量

**下界向量 l（第 3n 到 4n-2 行，共 n-1 行）：**
```
l = [j_min · Δt · s₂,
     j_min · Δt · s₂,
     ...,
     j_min · Δt · s₂]ᵀ    ← 共 n-1 个元素
```

**上界向量 u（第 3n 到 4n-2 行）：**
```
u = [j_max · Δt · s₂,
     j_max · Δt · s₂,
     ...,
     j_max · Δt · s₂]ᵀ    ← 共 n-1 个元素
```

**约束含义：**
```
j_min · Δt · s₂ ≤ a_opt,i+1 - a_opt,i ≤ j_max · Δt · s₂
```

典型值：
- `j_min = -4.5 m/s³`，`j_max = 4.5 m/s³`
- `Δt = 0.1 s`，`s₂ = 100.0`
- 因此：`-45 ≤ a_opt,i+1 - a_opt,i ≤ 45`

### 示例（n=3）

```
约束矩阵（2行）：
第9行  | [0 0 0|0 0 0|-1 1 0] · x   →  a₁ - a₀  （对应 t₀→t₁）
第10行 | [0 0 0|0 0 0| 0-1 1] · x   →  a₂ - a₁  （对应 t₁→t₂）

边界：
  -4.5 · 0.1 · 100 ≤ a₁ - a₀ ≤ 4.5 · 0.1 · 100
  即：-45 ≤ a₁ - a₀ ≤ 45
```

---

## 第三部分：速度连续性约束

### 代码（第188-197行）

```cpp
// x(i+1)' - x(i)' - 0.5 * delta_s * x(i)'' - 0.5 * delta_s * x(i+1)'' = 0
for (int i = 0; i + 1 < n; ++i) {
    variables[n + i].emplace_back(constraint_index, -1.0 * scale_factor_[2]);
    variables[n + i + 1].emplace_back(constraint_index, 1.0 * scale_factor_[2]);
    variables[2 * n + i].emplace_back(constraint_index, -0.5 * delta_s_ * scale_factor_[1]);
    variables[2 * n + i + 1].emplace_back(constraint_index, -0.5 * delta_s_ * scale_factor_[1]);
    lower_bounds->at(constraint_index) = 0.0;
    upper_bounds->at(constraint_index) = 0.0;
    ++constraint_index;
}
```

### 物理推导

从时刻 i 到 i+1，速度变化：
```
vᵢ₊₁ = vᵢ + ∫[tᵢ, tᵢ₊₁] a(t) dt
```

使用**梯形积分**近似（假设加速度线性变化）：
```
vᵢ₊₁ = vᵢ + (aᵢ + aᵢ₊₁)/2 · Δt
```

整理为等式约束：
```
vᵢ₊₁ - vᵢ - Δt/2 · aᵢ - Δt/2 · aᵢ₊₁ = 0
```

### 缩放因子的数学推导

**关键问题**：为什么代码中的系数这么复杂？

#### 步骤1：优化变量与真实物理量的关系

```
v_opt = v_real × s₁
a_opt = a_real × s₂

即：
v_real = v_opt / s₁
a_real = a_opt / s₂
```

#### 步骤2：将缩放关系代入物理方程

原始物理方程：
```
v_real,i+1 - v_real,i = 0.5 × Δt × (a_real,i + a_real,i+1)
```

代入缩放关系：
```
v_opt,i+1/s₁ - v_opt,i/s₁ = 0.5 × Δt × (a_opt,i/s₂ + a_opt,i+1/s₂)
```

#### 步骤3：转换为优化器约束形式

两边同时乘以 s₁ × s₂：
```
s₂ × (v_opt,i+1 - v_opt,i) = 0.5 × Δt × s₁ × (a_opt,i + a_opt,i+1)
```

移项到左边（标准约束形式）：
```
-s₂ × v_opt,i + s₂ × v_opt,i+1 - 0.5×Δt×s₁ × a_opt,i - 0.5×Δt×s₁ × a_opt,i+1 = 0
```

#### 步骤4：对照代码

```cpp
variables[n + i].emplace_back(constraint_index, -1.0 * scale_factor_[2]);           // -s₂
variables[n + i + 1].emplace_back(constraint_index, 1.0 * scale_factor_[2]);        //  s₂
variables[2 * n + i].emplace_back(constraint_index, -0.5 * delta_s_ * scale_factor_[1]);     // -0.5×Δt×s₁
variables[2 * n + i + 1].emplace_back(constraint_index, -0.5 * delta_s_ * scale_factor_[1]); // -0.5×Δt×s₁
```

**系数对照表：**

| 变量 | 代码系数 | 数学推导 | 匹配 |
|------|---------|---------|------|
| v_opt,i | `-scale_factor_[2]` | `-s₂` | ✓ |
| v_opt,i+1 | `scale_factor_[2]` | `s₂` | ✓ |
| a_opt,i | `-0.5 * delta_s_ * scale_factor_[1]` | `-0.5×Δt×s₁` | ✓ |
| a_opt,i+1 | `-0.5 * delta_s_ * scale_factor_[1]` | `-0.5×Δt×s₁` | ✓ |

**重要结论**：
- 速度项的系数包含 `s₂`（加速度的缩放因子）
- 加速度项的系数包含 `s₁`（速度的缩放因子）
- 这种"交叉使用"确保了物理方程在缩放后依然严格成立
- **缩放因子之间不需要满足特殊关系**（如 s₁ = s₂），约束矩阵的系数会自动调整

### 矩阵形式（n-1 行，等式约束）

```
第 i 个约束涉及：v_opt,i, v_opt,i+1, a_opt,i, a_opt,i+1

A矩阵的这一行：
[0 ... 0 | 0 ... -s₂  s₂  0 ... | 0 ... -0.5Δt·s₁  -0.5Δt·s₁  0 ...]
                  ↑    ↑                    ↑          ↑
             v_opt,i  v_opt,i+1      a_opt,i    a_opt,i+1
```

### 上下界向量

**下界向量 l（第 4n-1 到 5n-3 行，共 n-1 行）：**
```
l = [0,
     0,
     ...,
     0]ᵀ    ← 共 n-1 个元素，全为 0（等式约束）
```

**上界向量 u（第 4n-1 到 5n-3 行）：**
```
u = [0,
     0,
     ...,
     0]ᵀ    ← 共 n-1 个元素，全为 0（等式约束）
```

**约束含义：**这是等式约束，上下界相等：
```
s₂ × (v_opt,i+1 - v_opt,i) - 0.5×Δt×s₁ × (a_opt,i + a_opt,i+1) = 0
```

### 示例（n=3, Δt=0.1, s₁=10, s₂=100）

```
第11行约束（v₀→v₁）：
  [0 0 0|-100 100 0|-0.5 -0.5 0] · x = 0
  即：100(v₁ - v₀) - 0.5(a₀ + a₁) = 0

第12行约束（v₁→v₂）：
  [0 0 0|0 -100 100|0 -0.5 -0.5] · x = 0
  即：100(v₂ - v₁) - 0.5(a₁ + a₂) = 0
```

---

## 第四部分：位置连续性约束

### 代码（第199-213行）

```cpp
// x(i+1) - x(i) - delta_s * x(i)'
// - 1/3 * delta_s^2 * x(i)'' - 1/6 * delta_s^2 * x(i+1)''
auto delta_s_sq_ = delta_s_ * delta_s_;
for (int i = 0; i + 1 < n; ++i) {
    variables[i].emplace_back(constraint_index, -1.0 * scale_factor_[1] * scale_factor_[2]);
    variables[i + 1].emplace_back(constraint_index, 1.0 * scale_factor_[1] * scale_factor_[2]);
    variables[n + i].emplace_back(constraint_index, -delta_s_ * scale_factor_[0] * scale_factor_[2]);
    variables[2 * n + i].emplace_back(constraint_index, -delta_s_sq_ / 3.0 * scale_factor_[0] * scale_factor_[1]);
    variables[2 * n + i + 1].emplace_back(constraint_index, -delta_s_sq_ / 6.0 * scale_factor_[0] * scale_factor_[1]);
    lower_bounds->at(constraint_index) = 0.0;
    upper_bounds->at(constraint_index) = 0.0;
    ++constraint_index;
}
```

### 物理推导

从时刻 i 到 i+1，位置变化：
```
sᵢ₊₁ = sᵢ + ∫[tᵢ, tᵢ₊₁] v(t) dt
```

而速度又满足：
```
v(t) = vᵢ + ∫[tᵢ, t] a(τ) dτ
```

假设加速度在 [tᵢ, tᵢ₊₁] 内**线性插值**：
```
a(t) = aᵢ + (aᵢ₊₁ - aᵢ) · (t - tᵢ)/Δt
```

代入积分得到：
```
sᵢ₊₁ = sᵢ + vᵢ·Δt + (1/2)aᵢ·Δt² + (1/6)(aᵢ₊₁ - aᵢ)·Δt²
     = sᵢ + vᵢ·Δt + (1/3)aᵢ·Δt² + (1/6)aᵢ₊₁·Δt²
```

整理为等式约束：
```
sᵢ₊₁ - sᵢ - Δt·vᵢ - (Δt²/3)·aᵢ - (Δt²/6)·aᵢ₊₁ = 0
```

### 缩放因子解释

代码中的系数：
```cpp
variables[i].emplace_back(constraint_index, -1.0 * scale_factor_[1] * scale_factor_[2]);        // sᵢ
variables[i + 1].emplace_back(constraint_index, 1.0 * scale_factor_[1] * scale_factor_[2]);    // sᵢ₊₁
variables[n + i].emplace_back(constraint_index, -delta_s_ * scale_factor_[0] * scale_factor_[2]);  // vᵢ
variables[2 * n + i].emplace_back(constraint_index, -delta_s_sq_ / 3.0 * scale_factor_[0] * scale_factor_[1]);     // aᵢ
variables[2 * n + i + 1].emplace_back(constraint_index, -delta_s_sq_ / 6.0 * scale_factor_[0] * scale_factor_[1]); // aᵢ₊₁
```

实际约束：
```
s₁·s₂·(sᵢ₊₁ - sᵢ) - Δt·s₀·s₂·vᵢ - (Δt²/3)·s₀·s₁·aᵢ - (Δt²/6)·s₀·s₁·aᵢ₊₁ = 0
```

### 矩阵形式（n-1 行，等式约束）

```
第 i 个约束涉及：s_opt,i, s_opt,i+1, v_opt,i, a_opt,i, a_opt,i+1

A矩阵的这一行：
[... -s₁s₂  s₁s₂ ... | ... -Δt·s₀s₂  0 ... | ... -(Δt²/3)s₀s₁  -(Δt²/6)s₀s₁  0 ...]
     ↑      ↑                ↑                        ↑              ↑
  s_opt,i  s_opt,i+1      v_opt,i              a_opt,i        a_opt,i+1
```

### 上下界向量

**下界向量 l（第 5n-2 到 6n-4 行，共 n-1 行）：**
```
l = [0,
     0,
     ...,
     0]ᵀ    ← 共 n-1 个元素，全为 0（等式约束）
```

**上界向量 u（第 5n-2 到 6n-4 行）：**
```
u = [0,
     0,
     ...,
     0]ᵀ    ← 共 n-1 个元素，全为 0（等式约束）
```

**约束含义：**这是等式约束，确保位置曲线连续：
```
s₁·s₂·(s_opt,i+1 - s_opt,i) - Δt·s₀·s₂·v_opt,i - (Δt²/3)·s₀·s₁·a_opt,i - (Δt²/6)·s₀·s₁·a_opt,i+1 = 0
```

### 示例（n=3, Δt=0.1, s₀=1, s₁=10, s₂=100）

```
第13行约束（s₀→s₁）：
  [-1000 1000 0|-10 0 0|-0.333 -0.167 0] · x = 0
  即：1000(s₁-s₀) - 10·v₀ - 0.333·a₀ - 0.167·a₁ = 0

第14行约束（s₁→s₂）：
  [0 -1000 1000|0 -10 0|0 -0.333 -0.167] · x = 0
  即：1000(s₂-s₁) - 10·v₁ - 0.333·a₁ - 0.167·a₂ = 0
```

---

## 第五部分：初始状态约束

### 代码（第215-229行）

```cpp
// constrain on x_init
variables[0].emplace_back(constraint_index, 1.0);
lower_bounds->at(constraint_index) = x_init_[0] * scale_factor_[0];
upper_bounds->at(constraint_index) = x_init_[0] * scale_factor_[0];
++constraint_index;

variables[n].emplace_back(constraint_index, 1.0);
lower_bounds->at(constraint_index) = x_init_[1] * scale_factor_[1];
upper_bounds->at(constraint_index) = x_init_[1] * scale_factor_[1];
++constraint_index;

variables[2 * n].emplace_back(constraint_index, 1.0);
lower_bounds->at(constraint_index) = x_init_[2] * scale_factor_[2];
upper_bounds->at(constraint_index) = x_init_[2] * scale_factor_[2];
++constraint_index;
```

### 物理意义

固定起点状态（等式约束）：
```
s₀ = s_init
v₀ = v_init
a₀ = a_init
```

### 矩阵形式（3 行）

```
最后3行约束：
[1 0 0 ... 0] · x = s_init · s₀     (固定 s_opt,0)
[0 ... 0 1 0 ... 0] · x = v_init · s₁     (固定 v_opt,0)
[0 ... 0 1 0 ... 0] · x = a_init · s₂     (固定 a_opt,0)
          ↑              ↑
     v_opt,0位置     a_opt,0位置
```

### 上下界向量

**下界向量 l（最后 3 行）：**
```
l = [s_init · s₀,
     v_init · s₁,
     a_init · s₂]ᵀ
```

**上界向量 u（最后 3 行）：**
```
u = [s_init · s₀,
     v_init · s₁,
     a_init · s₂]ᵀ
```

**约束含义：**这是等式约束，上下界相等，固定初始状态：
```
s_opt,0 = s_init · s₀
v_opt,0 = v_init · s₁
a_opt,0 = a_init · s₂
```

### 示例

假设初始状态：s_init=0, v_init=5.0m/s, a_init=0

```
第15行 | [1 0 0|0 0 0|0 0 0] · x = 0 · 1 = 0        (s₀ = 0)
第16行 | [0 0 0|1 0 0|0 0 0] · x = 5.0 · 10 = 50    (v₀ = 5.0)
第17行 | [0 0 0|0 0 0|1 0 0] · x = 0 · 100 = 0      (a₀ = 0)
```

---

## 完整示例

假设 n=3（3个时间节点），我们来看完整的约束矩阵。

### 决策变量

```
x = [s₀, s₁, s₂, v₀, v₁, v₂, a₀, a₁, a₂]ᵀ  （9个变量）
```

### 约束矩阵 A（18行×9列）

```
        s₀  s₁  s₂  v₀  v₁  v₂  a₀   a₁   a₂
行0:  [ 1   0   0   0   0   0   0    0    0 ]  s₀边界
行1:  [ 0   1   0   0   0   0   0    0    0 ]  s₁边界
行2:  [ 0   0   1   0   0   0   0    0    0 ]  s₂边界
行3:  [ 0   0   0   1   0   0   0    0    0 ]  v₀边界
行4:  [ 0   0   0   0   1   0   0    0    0 ]  v₁边界
行5:  [ 0   0   0   0   0   1   0    0    0 ]  v₂边界
行6:  [ 0   0   0   0   0   0   1    0    0 ]  a₀边界
行7:  [ 0   0   0   0   0   0   0    1    0 ]  a₁边界
行8:  [ 0   0   0   0   0   0   0    0    1 ]  a₂边界
行9:  [ 0   0   0   0   0   0  -1    1    0 ]  jerk₀ = a₁-a₀
行10: [ 0   0   0   0   0   0   0   -1    1 ]  jerk₁ = a₂-a₁
行11: [ 0   0   0 -100 100 0  -0.5 -0.5  0 ]  v连续性(0→1)
行12: [ 0   0   0   0 -100 100  0  -0.5 -0.5] v连续性(1→2)
行13: [-1000 1000 0 -10  0  0 -0.33 -0.17 0] s连续性(0→1)
行14: [ 0 -1000 1000 0 -10 0  0  -0.33 -0.17] s连续性(1→2)
行15: [ 1   0   0   0   0   0   0    0    0 ]  初始s₀
行16: [ 0   0   0   1   0   0   0    0    0 ]  初始v₀
行17: [ 0   0   0   0   0   0   1    0    0 ]  初始a₀
```

### 边界向量

```
约束  |  下界 l           |  上界 u           | 类型
------|------------------|------------------|--------
0-8   | 变量下界           | 变量上界           | 不等式
9-10  | -45              | 45               | jerk限制
11-12 | 0                | 0                | 等式（速度连续）
13-14 | 0                | 0                | 等式（位置连续）
15-17 | 初始值            | 初始值            | 等式（初始状态）
```

---

## 总结

### 约束的物理意义

| 约束类型 | 物理意义 | 为什么需要 |
|---------|---------|-----------|
| 变量边界 | 限制位置、速度、加速度范围 | 物理可行性和安全性 |
| Jerk约束 | 限制加速度变化率 | 乘坐舒适性 |
| 速度连续性 | 确保速度曲线平滑 | 运动学一致性 |
| 位置连续性 | 确保位置曲线平滑 | 运动学一致性 |
| 初始状态 | 从当前状态出发 | 可执行性 |

### 缩放因子总结

缩放因子 `scale_factor_ = [s₀, s₁, s₂] = [1.0, 10.0, 100.0]` 的作用：

1. **数值稳定性**：让不同量级的变量（位置~100m，速度~10m/s，加速度~1m/s²）在数值上更接近
2. **优化效率**：避免病态矩阵，提高求解器收敛速度
3. **精度均衡**：确保各个变量的优化精度相当

**重要特性**：
- **缩放关系**：`x_opt = x_real × scale_factor`
- **不需要特殊关系**：缩放因子之间不需要满足 s₁ = s₂ 等特殊条件
- **系数自动调整**：约束矩阵的系数"交叉使用"不同的缩放因子（例如速度项用 s₂，加速度项用 s₁）
- **物理方程不变**：缩放后物理方程依然严格成立

详细推导见 [第三部分：速度连续性约束](#第三部分速度连续性约束) 中的"缩放因子的数学推导"部分。

### 代码-数学对照表

| 代码变量 | 数学符号 | 含义 |
|---------|---------|------|
| `num_of_knots_` | n | 时间节点数 |
| `delta_s_` | Δt | 时间步长 |
| `x_bounds_` | [s_min, s_max] | 位置边界 |
| `dx_bounds_` | [v_min, v_max] | 速度边界 |
| `ddx_bounds_` | [a_min, a_max] | 加速度边界 |
| `dddx_bound_` | [j_min, j_max] | jerk边界 |
| `x_init_` | [s₀, v₀, a₀] | 初始状态 |
| `scale_factor_` | [s₀, s₁, s₂] | 缩放因子 |

---

## 参考资料

- 代码位置：`modules/planning/planning_base/math/piecewise_jerk/piecewise_jerk_problem.cc`
- OSQP求解器文档：https://osqp.org/
- 三次样条插值：https://en.wikipedia.org/wiki/Spline_interpolation

